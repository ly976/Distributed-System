From e4bc6322b3e32f3fa4bb187756bf3e8205f11852 Mon Sep 17 00:00:00 2001
From: Luying Yan <ly976@nyu.edu>
Date: Sun, 8 Oct 2017 22:14:27 -0400
Subject: [PATCH] testing

---
 src/main/wc.go             |  23 ++++++++++-
 src/mapreduce/mapreduce.go |  11 ++++-
 src/mapreduce/master.go    | 101 ++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 131 insertions(+), 4 deletions(-)

diff --git a/src/main/wc.go b/src/main/wc.go
index 3846bad..b468e99 100644
--- a/src/main/wc.go
+++ b/src/main/wc.go
@@ -3,7 +3,9 @@ package main
 import "os"
 import "fmt"
 import "mapreduce"
-
+import "strings"
+import "strconv"
+import "unicode"
 import "container/list"
 
 // our simplified version of MapReduce does not supply a
@@ -12,12 +14,31 @@ import "container/list"
 // value should be a list of key/value pairs, each represented
 // by a mapreduce.KeyValue.
 func Map(value string) *list.List {
+	notLetter := func(r rune) bool {
+		return !unicode.IsLetter(r)
+	}
+	fields := strings.FieldsFunc(value, notLetter)
+
+	l := list.New()
+	for _, f := range fields {
+		kv := mapreduce.KeyValue{Key: f, Value: "1"}
+		l.PushBack(kv)
+	}
+	return l
 }
 
 // called once for each key generated by Map, with a list
 // of that key's string value. should return a single
 // output value for that key.
 func Reduce(key string, values *list.List) string {
+	count := 0
+	// iterate over list
+	for e := values.Front(); e != nil; e = e.Next() {
+		v := e.Value.(string)
+		intValue, _ := strconv.Atoi(v)
+		count += intValue
+	}
+	return strconv.Itoa(count)
 }
 
 // Can be run in 3 ways:
diff --git a/src/mapreduce/mapreduce.go b/src/mapreduce/mapreduce.go
index 470e6f1..3864e47 100644
--- a/src/mapreduce/mapreduce.go
+++ b/src/mapreduce/mapreduce.go
@@ -63,7 +63,11 @@ type MapReduce struct {
 	// Map of registered workers that you need to keep up to date
 	Workers map[string]*WorkerInfo
 
-	// add any additional state here
+	//channel for registered workers to announce availability
+  	available chan string
+
+  	//channel to send job responses 
+  	responses chan *ReplyInfo
 }
 
 func InitMapReduce(nmap int, nreduce int,
@@ -77,7 +81,10 @@ func InitMapReduce(nmap int, nreduce int,
 	mr.registerChannel = make(chan string)
 	mr.DoneChannel = make(chan bool)
 
-	// initialize any additional state here
+	mr.Workers = make(map[string] *WorkerInfo)
+	
+	mr.available = make(chan string)
+	mr.responses = make(chan *ReplyInfo, nmap)
 	return mr
 }
 
diff --git a/src/mapreduce/master.go b/src/mapreduce/master.go
index b15363b..d20cc57 100644
--- a/src/mapreduce/master.go
+++ b/src/mapreduce/master.go
@@ -9,6 +9,12 @@ type WorkerInfo struct {
 	// You can add definitions here.
 }
 
+type ReplyInfo struct{
+	job int
+	OK bool
+	reply *DoJobReply
+}
+
 
 // Clean up all workers by sending a Shutdown RPC to each one of them Collect
 // the number of jobs each work has performed.
@@ -29,6 +35,99 @@ func (mr *MapReduce) KillWorkers() *list.List {
 }
 
 func (mr *MapReduce) RunMaster() *list.List {
-	// Your code here
+	//start registraion thread
+	go ReceiveRegister(mr)
+	completed := 0 //tally of completed jobs
+	
+	//create list of outstanding jobs
+	jobs := list.New() 
+	for i := 0; i < mr.nMap; i++{
+		jobs.PushFront(i)
+	}
+
+	//loop for the map stage
+	for completed != mr.nMap {
+		listen(mr, Map, &completed, jobs)
+	}
+	
+	//start reduce jobs once maps are done
+	completed = 0
+	jobs.Init() //clear list
+	for i := 0; i < mr.nReduce; i++{
+		jobs.PushFront(i)
+	}
+	for completed != mr.nReduce {
+		listen(mr, Reduce, &completed, jobs)
+	}
+	
+	//yaaaay we're done
 	return mr.KillWorkers()
 }
+
+func listen(mr *MapReduce, stage JobType, completed *int, jobs *list.List){
+	
+	NumOther := 0
+	switch stage {
+	case Map:
+		NumOther = mr.nReduce
+	case Reduce:
+		NumOther = mr.nMap
+	}
+
+	if jobs.Len() != 0 {
+		select{
+		//wait for worker responses
+		case r := <-mr.responses:
+			HandleResponse(r, completed, jobs)
+
+		//wait for available if none are available
+		case id := <- mr.available:
+			w := mr.Workers[id]
+			//pop off a job id
+			j := jobs.Remove(jobs.Front()).(int)
+			args := &DoJobArgs{mr.file, stage, j, NumOther}
+			go SendRPC(mr, w, args, j)	
+		}	
+	} else {
+		r := <-mr.responses
+		HandleResponse(r, completed, jobs)
+	}
+}
+
+func HandleResponse(r *ReplyInfo, completed *int, jobs *list.List){
+	if r.OK {
+		//add to our completed count
+		*completed++
+	} else {
+		//add job back to queue, it failed.
+		jobs.PushFront(r.job)
+	}
+}
+
+func ReceiveRegister(mr *MapReduce){
+	//a blocking listen for new worker registration
+	for {
+		addr := <- mr.registerChannel
+		//add new worker to map. key is integer cause I can't think of anything better
+		w := WorkerInfo{addr}
+		mr.Workers[addr] = &w
+		//announce available worker on channel
+		mr.available <- addr
+	}
+}
+
+func SendRPC(mr *MapReduce, w *WorkerInfo, args *DoJobArgs, job int){
+	var reply DoJobReply
+	success := call(w.address, "Worker.DoJob", args, &reply)
+	//put reply on channel, regardless of success
+	mr.responses <- &ReplyInfo{job, success, &reply}
+
+	if success{
+		//put worker on channel available
+		mr.available <- w.address	
+	} else {
+		//de-register this dead worker
+		delete(mr.Workers, w.address)
+	}
+}
+
-- 
2.10.1

